# [풀이 코드](./BOJ_S3_15649.java)

<br>

1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열을 구하는 문제이다. "N과 M" 시리즈는 이전에 이미 Python으로 다 풀었던 경험이 있어서 Java로도 수월하게 해결할 수 있었다.

<br>

## 백트래킹

다음과 같이 순열 문제를 해결하기 위한 전형적인 백트래킹 로직을 사용했다.

```java
public static void backtracking(int count) {
    if (count == M) {
        for (int i = 0; i < M; ++i) {
            System.out.print(result_list[i] + " ");
        }
        System.out.println();
        return;
    }

    for (int i = 0; i < N; ++i) {
        if (visited[i]) {
            continue;
        }
        result_list[count] = n_list[i];
        visited[i] = true;
        backtracking(count + 1);
        visited[i] = false;
    }
}
```

백트래킹을 구현할 때마다 습관적으로 백트래킹 깊이에 대한 변수 명을 `count`로 지어서 사용하게 된다. `depth`라는 변수명이 더 적합하므로 다음부터는 `count`가 아니라 `depth`를 사용할 예정이다.

<br>
이 문제의 백트래킹에서 상태관리는 다음과 같은 변수들로 이루어진다.

- n_list[]
  - 수열에 들어갈 수 있는 숫자들의 배열
  - 문제에서는 이러한 숫자들의 모음이 1부터 N라고 지정되어 있지만, 백트래킹의 로직을 직관적으로 보여주기 위해 사용함.
- visited[]
  - 각 숫자의 사용 여부 추적
- result_list[]
  - 현재까지 선택한 수열을 저장

<br>

백트래킹 과정은 다음과 같이 전형적인 순서를 띈다.

1. 기저 조건 충족(depth == M)이면 완성된 수열 출력
2. 수열을 출력하고 나서 다른 경우의 수를 탐색하기 위해, 선택을 취소하고 되돌리기(백트래킹)
3. 수열이 완성되지 않았으면 아직 사용하지 않은 숫자 중 하나를 선택
4. 재귀 호출로 다음 깊이 진행

<br>

해당 코드의 시간복잡도는 O(N!)로 백트래킹을 사용한 최적의 시간복잡도이이다. <br>

```text
수열의 첫번째 자리: (N)개 선택 가능
수열의 두번째 자리: (N-1)개 선택 가능
수열의 세번째 자리: (N-2)개 선택 가능
...
수열의 M번째 자리: (N-M+1)개 선택 가능
```

따라서 총 경우의 수는 다음과 같이 계산할 수 있다. <br>
N \* (N - 1) \* (N - 2) \* ... \* (N - M + 1) = N! / (N - M)! <br>
그러므로 시간복잡도는 O(N!)이 된다.
<br>
