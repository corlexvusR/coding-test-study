# [풀이 코드](./BOJ_S1_1629.java)

<br>

자연수 A를 B번 곱한 수를 구하는 문제다. **그리고 구하려는 수가 매우 커질 수 있으므로 이를 특정 수로 나눈 나머지를 요구한다.** 수학적 성질을 사용하면 간결하게 풀 수 있다. 그러나 Java는 Python과 달리 타입으로 인한 오버플로우가 생길 수 있다. Python은 자동 임의 정밀도 처리와 자동 타입 승격이 있지만, Java에서는 별도로 타입 캐스팅을 해주어야 한다. 이를 간과한 나머지 오늘도 어김없이 "틀렸습니다" 1회를 적립하고 말았다. 이런 현실이 있단 말인가...

<br>

## 모듈러 거듭제곱(Modular Exponentiation)을 분할 정복(Divide and Conquer) 방식으로 구현

A^B % B를 다음과 같은 수학적 성질을 이용해 효율적으로 계산할 수 있다.

- 지수가 짝수일 때: `A^B = (A^(B/2))^2`
- 지수가 홀수일 때: `A^B = A\*(A^(B/2))^2`

단순히 A를 B번 곱하면 시간복잡도는 O(B)이다. 그러나 이러한 성질을 이용하면 매번 지수를 절반으로 줄이게 되므로 O(log B)의 시간복잡도로 구현할 수 있다. 만약 B가 2,147,483,647일 때 일반적인 방법으로는 21억 번 연산해야 하지만, 분할 정복으로는 약 31번만 연산하면 된다.

```java
public static int power(int A, int B, int C) {
    if (B == 0) {
        return 1;
    } else if (B == 1) {
        return A % C;
    }

    int half = power(A, B / 2, C);

    if (B % 2 == 0) {
        return (int)(((long)half * half) % C);
    } else {
        return (int)((((long)half * half) % C * (A % C)) % C);
    }
}
```

<br>

## `power` 함수의 기저 조건

제곱의 성질을 감안해서 다음과 같은 기저 조건을 구현한다.

```java
if (B == 0) {
    return 1;
} else if (B == 1) {
    return A % C;
}
```

특정 수의 0제곱은 1이므로 B가 0일 때는 `1`을 반환한다.
<br>
특정 수의 1제곱은 A이다. 혹시 모르니 `A % C`를 반환하도록 한다.

<br>

## `power` 함수의 분할 정복

B를 절반으로 나누어 재귀 호출을 한다. 이를 통해 `A^(B/2) % 2`를 계산한다.

```java
int half = power(A, B / 2, C);
```

<br>

## `power` 함수의 분할 정복 결과 조합

분할 정복한 결과를 조합하여 A를 B번 곱한 수를 계산한다. 이전에 언급했던 다음의 수학적 성질을 이용했다.

- 지수가 짝수일 때: `A^B = (A^(B/2))^2`
- 지수가 홀수일 때: `A^B = A\*(A^(B/2))^2`

```java
if (B % 2 == 0) {
    return (int)(((long)half * half) % C);
} else {
    return (int)((((long)half * half) % C * (A % C)) % C);
}
```

여기서 곱셈 전에 `half`를 `long` 타입으로 캐스팅해야 오버플로우를 방지할 수 있다. 문제에서 주어지는 값이 최대 2,147,483,647이므로, `half`가 최대값에 가까울 때 `half * half`는 java의 `int` 범위를 벗어날 수 있기 때문이다. 곱셈이 완료되고 나면 결과값을 다시 `int`로 캐스팅하여 반환했다.
<br>
`long`과 `int`로 캐스팅하지 않고 처음부터 `long` 타입으로 A, B, C에 대한 값을 입력 받았어도 되었겠지만, 문제에서 모듈러 연산을 요구하는 것을 감안하여 필요할 때 타입 캐스팅을 사용하는 방식으로 구현했다.

<br>
